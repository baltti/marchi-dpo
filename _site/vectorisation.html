<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Оцифровка материалов – Цифровые средства градостроительного анализа</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./vectorisation.html">Векторизация растровых карт</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Цифровые средства градостроительного анализа</a> 
    </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">О курсе</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Источники данных о территории</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Data-sources.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Открытые источники данных</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./building-parameters.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Источники данных о характеристиках застройки</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./remote-sensing-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Открытые данные дистанционного зондирования</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./vectorisation.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Векторизация растровых карт</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Работа с данными дистанционного зондирования</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./remote-sensing-basic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Основы работы с данными дистанционного зондирования в ГИС</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./vegetation-indices.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Расчет вегетационных индексов</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./surface-temperature.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Определение температуры поверхности по космическим снимкам</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./image-classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Распознавание объектов на снимках</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./relief.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Анализ рельефа</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#georeferencing" id="toc-georeferencing" class="nav-link active" data-scroll-target="#georeferencing"><span class="header-section-number">1</span> Геопривязка растра</a></li>
  <li><a href="#ручная-векторизация" id="toc-ручная-векторизация" class="nav-link" data-scroll-target="#ручная-векторизация"><span class="header-section-number">2</span> Ручная векторизация</a>
  <ul class="collapse">
  <li><a href="#создание-нового-слоя-и-добавление-в-него-объектов" id="toc-создание-нового-слоя-и-добавление-в-него-объектов" class="nav-link" data-scroll-target="#создание-нового-слоя-и-добавление-в-него-объектов"><span class="header-section-number">2.1</span> Создание нового слоя и добавление в него объектов</a></li>
  <li><a href="#прилипание-объектов" id="toc-прилипание-объектов" class="nav-link" data-scroll-target="#прилипание-объектов"><span class="header-section-number">2.2</span> Прилипание объектов</a></li>
  <li><a href="#редактирование-объектов" id="toc-редактирование-объектов" class="nav-link" data-scroll-target="#редактирование-объектов"><span class="header-section-number">2.3</span> Редактирование объектов</a></li>
  </ul></li>
  <li><a href="#автоматическая-векторизация" id="toc-автоматическая-векторизация" class="nav-link" data-scroll-target="#автоматическая-векторизация"><span class="header-section-number">3</span> Автоматическая векторизация</a>
  <ul class="collapse">
  <li><a href="#встроенные-стредства-qgis" id="toc-встроенные-стредства-qgis" class="nav-link" data-scroll-target="#встроенные-стредства-qgis"><span class="header-section-number">3.1</span> Встроенные стредства QGIS</a></li>
  <li><a href="#модуль-bunting-labs-ai" id="toc-модуль-bunting-labs-ai" class="nav-link" data-scroll-target="#модуль-bunting-labs-ai"><span class="header-section-number">3.2</span> Модуль Bunting labs AI</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Оцифровка материалов</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="georeferencing" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="georeferencing"><span class="header-section-number">1</span> Геопривязка растра</h2>
<p>В качестве исходной информации при векторизации, как правило, выступают растровые изображения. Это могут быть отсканированные оригиналы бумажных карт, выдержки из официальной документации, информация с градостроительных порталов, из градостроительной документации, спутниковые снимки или снимки, полученные с беспилотных летательных аппаратов, даже просто скриншоты экрана, а также тайловые подложки (типа той, что мы подгружаем из OpenStreetMap).</p>
<p><strong>Геопривязка растра</strong> - это присвоение растровому изображению нужной географической системы координат.</p>
<p>В процессе привязки на растровом изображении для каждого пикселя, у которого есть условные координаты на растре, находится соотвествующая координата в целевой системе координат.</p>
<p>В качестве исходных данных возьмем информацию с Градостроительного портала Санкт-Петербурга <a href="https://portal.kgainfo.spb.ru/KGAMap/Map" class="uri">https://portal.kgainfo.spb.ru/KGAMap/Map</a></p>
<p><img src="images/37.PNG" class="img-fluid"></p>
<p>Этот портал позволяет получать информацию из градостроительной документации Санкт-Петербурга, но только в растровом виде, выгрузки границ объектов в векторных форматах здесь не предусмотрено. Поэтому, если вы хотите воспользоваться данными портала, вам нужно будет из самостоятельно векторизовать.</p>
<p>Рассмотрим пример сохранения растровой картинки с границами функциональной зоны.</p>
<p>Для этого найдем на карте интересующую нас зону, щелкнем на нее, чтобы получить информацию об объектах в точке.</p>
<p><img src="images/38.png" class="img-fluid"></p>
<p>Далее выберем фунцию печати информации об функциональной зоне, после чего в новой вкладке откроется отчет с подробной информацией и схемой расположения объекта.</p>
<p>Просто сохраним картинку из отчета, чтобы в дальнейшем открыть ее в QGIS, выполнить геопривязку и осуществить векторизацию.</p>
<p>Создадим новый проект (рекомендую либо сразу его создавать в системе координат <code>EPSG:3857</code>, либо сразу после создания перепроецировать на лету в эту систему координат).</p>
<p>Для геопривязки растровых изображений в QGIS существует встроенный инструмент <a href="https://docs.qgis.org/3.28/en/docs/user_manual/working_with_raster/georeferencer.html">Привязка растров</a> (может называться Геопривязка).</p>
<p><img src="images/Снимок экрана 2025-04-11 в 10.23.55.png" class="img-fluid"></p>
<p>Далее откроется окно геопривязки растра.</p>
<p><img src="images/40.PNG" class="img-fluid"></p>
<p>В первую очередь нужно задать или проверить параметры трансформации растра (в строке меню <em>Параметры — Параметры трансформации</em>).</p>
<p><img src="images/41.PNG" class="img-fluid"></p>
<p>Основные параметры здесь:</p>
<ul>
<li><p>тип трансформации - алгоритм преобразования растрового изображения, подробнее <a href="https://docs.qgis.org/3.28/en/docs/user_manual/working_with_raster/georeferencer.html#available-transformation-algorithms">здесь</a>;</p></li>
<li><p>метод интерполяции;</p></li>
<li><p>целевая система координат - система координат, которую вы хотите присвоить растру;</p></li>
<li><p>целевой растр - нужно указать путь и название файла, полученного в результате привязки.</p></li>
</ul>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Тип трансформации будет определять манипуляции, выполняемые с растром: это может быть просто линейный пересчет координат или вместе с масштабированием и растяжением.</p>
<p>Примерно различные варианты типов трансформации показаны ниже.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/трансформация растра.png" class="img-fluid figure-img"></p>
<figcaption>Источник: https://gis.stackexchange.com/questions/367659/differences-between-different-georeferencing-transformation-algorithms-in-qgis</figcaption>
</figure>
</div>
</div>
</div>
<p>Для выполнения привязки нужно открыть растр <img src="images/42.PNG" class="img-fluid">, указать контрольные точки и их координаты в целевой системе координат.</p>
<p><img src="images/43.PNG" class="img-fluid"></p>
<p>Контрольные точки - это точки, по которым будет осуществляться привязка растрового изображения. У этих точек известны координаты на растровом изображении (как правило, в пикселях) и в целевой системе координат, то есть фактически по этим точкам растр “усаживается” в нужное место на карту.</p>
<p>Чтобы поставить контрольную точку, нужно щелкнуть на нее в окне привзяки на растре, а далее указать ее координаты в диалоговом окне.</p>
<p><img src="images/44.PNG" class="img-fluid"></p>
<p>Координаты можно ввести с клавиатуры (если они у вас есть), либо выбрать вариант <strong>С карты</strong> и просто щеклнуть на ту же самую точку на карте, после чего эти координаты пропишутся в диалоговом окне автоматически.</p>
<p>В качестве контрольных точек лучше всего использовать какие-то жесткие контура, на которых вы однозначно можете указать конкретную точку: угол дома, перекресток, угол парка и что-нибудь подобное.</p>
<p>Для различных вариантов трансформации рекомендуется разное минимальное число контрольных точек, но, как правило, общая рекомендация использовать не менее 3 точек. Желательно, чтобы эти точки не были расположены на одной линии.</p>
<p>После того, как вы укажете все контрольные точки и их координаты на карте, они будут отображены в таблице под растровым изображением в окне привязки.</p>
<p><img src="images/45.PNG" class="img-fluid"></p>
<p>Контрольные точки привязки можно сохранить и потом использовать в дальнейшем в других проектах (но только для того же самого растра).</p>
<p>Для завершения процесса привязки нужно нажать <strong>Начать привязку растра</strong> <img src="images/46.PNG" class="img-fluid"> после чего растр будет модифицирован и отобразиться в нужном месте на карте.</p>
<p><img src="images/47.PNG" class="img-fluid"></p>
<p>Этот модифицированный растр уже будет иметь в себе сведения о системе координат и его местоположении, поэтому его потом можно будет использовать в дальнейших проектах уже без процесса привязки.</p>
</section>
<section id="ручная-векторизация" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="ручная-векторизация"><span class="header-section-number">2</span> Ручная векторизация</h2>
<p><strong>Векторизация</strong> - процесс получения векторных географических данных. Как правило, имеется ввиду процесс получения на основе исходных растровых данных (сканированные карты, информация по официальным запросам, градостроительная документация и прочее).</p>
<section id="создание-нового-слоя-и-добавление-в-него-объектов" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="создание-нового-слоя-и-добавление-в-него-объектов"><span class="header-section-number">2.1</span> Создание нового слоя и добавление в него объектов</h3>
<p>Во всех предыдущих заданиях мы использовали уже готовые слои, которые просто добавляли в проект, но мы можем создавать и отрисовывать слои самостоятельно.</p>
<p>Для того, чтобы создать новый векторный слой в строке меню нужно выбрать <strong>Файл - Создать слой - Создать новый Geopackage слой</strong>.</p>
<p><img src="images/48.png" class="img-fluid"></p>
<p>После этого появится окно, в котором нужно задать имя файла, тип геометрии, систему координат, а также структуру таблицы атрибутов.</p>
<p><img src="images/49.PNG" class="img-fluid"></p>
<p>В качестве примера рассмотрим отрисовку домов, в атрибутивной таблице будут два поля: адрес и количество проживающих.</p>
<p><img src="images/50.PNG" class="img-fluid"></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>На этом этапе вы можете не создавать конкретную структуру таблицы атрибутов, так как вы всегда можете ее отредактировать позднее. По умолчанию будет создано 1 поле <strong>fid</strong>, которое будет заполнено автоматически номерами объектов.</p>
</div>
</div>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p>Рекомендую все файлы и названия полей делать латиницей, потому что QGIS может не всегда корректно работать с данными, путь к которым прописан русскими буквами, а также с русскими названиями полей.</p>
<p>Также следует помнить, что названия файлов и слоев, а также названия полей в атрибутивной таблице лучше делать осмысленными, чтобы вы потом могли понять, что содержится в ваших данных.</p>
<p>Если вы не уверены в том, какие атрибуты вам нужны, то помните, что вы всегда можете отредактировать таблицу атрибутов уже после создания слоя и отрисовки объектов.</p>
</div>
</div>
<p>После того, как вы создадите слой, то он появится у вас в списке слоев, но, конечно, никаких объектов на карту не добавится, потому что они пока не отрисованы.</p>
<p>Для начала отрисовки объектов в слое необходимо включить режим редактирования.</p>
<p><img src="images/51.png" class="img-fluid"></p>
<p>После включения режима редактирования на панели инструментов станут активными кнопки создания объектов и редактирования вершин <img src="images/52.PNG" class="img-fluid"> (так как у нас слой с площадными объектами, то предлагается только создания полигонов и их редактирование, если бы был другой тип геометрии инструменты были бы немного другими).</p>
<p>Для начала отрисовки объекта нужно щелкнуть на первую точку полигона, а потом по всем поворотным, завершается отрисовка контура щелчком правой кнопкой мыши.</p>
<p><img src="images/2021-12-01-12-46-06.gif" class="img-fluid"></p>
<p>По умолчанию в программе стоит настройка открывать окно ввода атрибутов для каждого созданного объекта.</p>
<p><img src="images/53.PNG" class="img-fluid"></p>
<p>В этом окне можно ввести характеристики объектов сразу, либо оставить пустым, просто нажав кнопку ОК (если вы здесь нажмете кнопку Отмена, то объект не будет создан).</p>
<p>Автоматическое появление формы ввода можно отключить в настройках программы.</p>
<p><img src="images/54.PNG" class="img-fluid"></p>
</section>
<section id="прилипание-объектов" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="прилипание-объектов"><span class="header-section-number">2.2</span> Прилипание объектов</h3>
<p>При отрисовке некоторых объектов важно, чтобы между ними были общие точки, общие границы, не было наложений или наоборот дырок между объектами. Для того, чтобы соблюдать эти правила, нужно пользоваться инструментами прилипания.</p>
<p><img src="images/55.png" class="img-fluid"></p>
<p>На панели инструментов прилипания доступны следующие функции (слева направо)</p>
<p><img src="images/56.PNG" class="img-fluid"></p>
<ul>
<li><p>разрешить прилипание;</p></li>
<li><p>выбор слоев, для которых будет доступно прилипание: все слои - прилипание будет осуществляться с учетом объектов всех слоев, которые есть в проекте (даже невидимых в данный момент), активный слой - прилипание будет осуществляться только для объектов текущего слоя.</p></li>
</ul>
<p><img src="images/58.png" class="img-fluid"></p>
<ul>
<li><p>тип объектов, к которым осуществляется прилипание (может быть выбрано сразу несколько вариантов):</p>
<ul>
<li><p>к вершинам - прилипание только к узловым точкам;</p></li>
<li><p>к линиям - прилипание к любой точке линии;</p></li>
<li><p>к поверхности - прилипание к любой точке внутри полигона;</p></li>
<li><p>к центроиду - прилипание к геометрическому центру полигона;</p></li>
<li><p>середина отрезка - прилипание только к середине линии;</p></li>
<li><p>конечные точки линии - прилипание только к начальной или конечной точке линии.</p></li>
</ul></li>
</ul>
<p><img src="images/59.png" class="img-fluid"></p>
<ul>
<li><p><em>порог прилипания</em> - то есть, в какой области вокруг курсора будет искаться объект для прилипания;</p></li>
<li><p><em>топологическое редактирование</em> позволяет сохранять общие границы между объектами. Если эта опция включена, то программа будет автоматически перестраивать общую границу для двух объектов (если таковая граница есть);</p></li>
<li><p>допустимы ли наложения между объектами;</p></li>
<li><p>разрешать <em>прилипание к пересечениям</em> - прилипание будет осуществляться к пересечениям двух объектов, даже если там нет вершины;</p></li>
<li><p><em>трассирование</em> (tracing) - позволяет ускорить привязку к линейным объектам, при включении этой опции вам не нужно будет прощелкивать по всей линии, достаточно будет нескольких точек (если установаить значение отступа offset, то можно построить линию, параллельную существующей);</p></li>
<li><p><em>самоприлипание</em> - позволяет осуществлять привязку отрисовываемого объекта к самому себе.</p></li>
</ul>
<p><img src="images/2021-12-01-13-20-37.gif" class="img-fluid"></p>
</section>
<section id="редактирование-объектов" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="редактирование-объектов"><span class="header-section-number">2.3</span> Редактирование объектов</h3>
<section id="редактирование-формы-объектов" class="level4" data-number="2.3.1">
<h4 data-number="2.3.1" class="anchored" data-anchor-id="редактирование-формы-объектов"><span class="header-section-number">2.3.1</span> Редактирование формы объектов</h4>
<p>Для редактирования формы объектов следует пользоваться инструментом работы с вершинами <img src="images/60.PNG" class="img-fluid"></p>
<p><img src="images/2021-12-01-13-25-36.gif" class="img-fluid"></p>
<p>Также для редактирования объектов есть целый ряд функций, представленных в пункте <strong>Правка</strong> <span class="math inline">\(\longrightarrow\)</span> <strong>Редактировать геометрию</strong> строки меню.</p>
<p><img src="images/61.png" class="img-fluid"></p>
</section>
<section id="перемещение-объекта" class="level4" data-number="2.3.2">
<h4 data-number="2.3.2" class="anchored" data-anchor-id="перемещение-объекта"><span class="header-section-number">2.3.2</span> Перемещение объекта</h4>
<p><img src="images/62.gif" class="img-fluid"></p>
</section>
<section id="поворот-объекта" class="level4" data-number="2.3.3">
<h4 data-number="2.3.3" class="anchored" data-anchor-id="поворот-объекта"><span class="header-section-number">2.3.3</span> Поворот объекта</h4>
<p><img src="images/63.gif" class="img-fluid"></p>
</section>
<section id="разбивка-объекта" class="level4" data-number="2.3.4">
<h4 data-number="2.3.4" class="anchored" data-anchor-id="разбивка-объекта"><span class="header-section-number">2.3.4</span> Разбивка объекта</h4>
<p><img src="images/64.gif" class="img-fluid"></p>
</section>
<section id="преобразование-объекта-в-кольцо" class="level4" data-number="2.3.5">
<h4 data-number="2.3.5" class="anchored" data-anchor-id="преобразование-объекта-в-кольцо"><span class="header-section-number">2.3.5</span> Преобразование объекта в кольцо</h4>
<p><img src="images/65.gif" class="img-fluid"></p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Более подробно с функциями редактирования векторных объектов можно ознакомиться в документации по <a href="https://docs.qgis.org/3.28/en/docs/user_manual/working_with_vector/editing_geometry_attributes.html#advanced-digitizing">ссылке</a></p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Для удобства дополнительный инструменты оцифровки можно включить из строки меню <em>Вид</em> <span class="math inline">\(\longrightarrow\)</span> <em>Панели инструментов</em> <span class="math inline">\(\longrightarrow\)</span> <em>Дополнительные инструменты оцифровки</em> (и <em>Панель инструментов оцифровки</em>).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Снимок экрана 2025-03-03 в 14.47.48.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p><em>Дополнительные инструменты оцифровки</em> включают в себя инструменты, входящие в группу инструментов изменения геометрии.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Снимок экрана 2025-03-03 в 14.55.39.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p><em>Панель инструментов оцифровки</em> включает в себя инструменты создания геометрических объектов определенной формы: эллипсы, прямоугольники и многоугольники.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Снимок экрана 2025-03-03 в 14.55.50.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>Также есть еще одна панель дополнительных инструментов оцифровки, открываемая из пункта меню <em>Вид</em> <span class="math inline">\(\longrightarrow\)</span> <em>Панели</em> <span class="math inline">\(\longrightarrow\)</span> <em>Дополнительные инструменты оцифровки.</em></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Снимок экрана 2025-03-03 в 14.59.17.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>Открытая таким образом панель позволяет создавать геометрические объекты по их параметрам: задавая длины линий, углы между линиями и прочее. Подробнее про нее прочитать можно в <a href="https://docs.qgis.org/3.40/en/docs/user_manual/working_with_vector/editing_geometry_attributes.html#the-advanced-digitizing-panel">документации</a>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Снимок экрана 2025-03-03 в 15.00.39.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>В последнем обновлении версии QGIS 3.42 появились новые функции, упрощающие отрисовку объектов<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>:</p>
<ul>
<li>обрезать\вытянуть объект</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/7.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/afff864bb555fcfba93b700cf4f63c7e2eb65390.gif" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<ul>
<li>добавлена опция привязки объектов в геопривязке.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/5d2403406b6bf2644f6ba0d60a77364dc80b4c7b.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="автоматическая-векторизация" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="автоматическая-векторизация"><span class="header-section-number">3</span> Автоматическая векторизация</h2>
<section id="встроенные-стредства-qgis" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="встроенные-стредства-qgis"><span class="header-section-number">3.1</span> Встроенные стредства QGIS</h3>
<p>По умолчанию в QGIS есть инструмент преобразования растра в вектор, то есть автоматической векторизации.</p>
<p>Этот инструмент может быть запущен из строки меню <em>Растр</em> <span class="math inline">\(\longrightarrow\)</span> <em>Преобразование</em> <span class="math inline">\(\longrightarrow\)</span> <em>Создание полигонов (растр в вектор)</em>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Снимок экрана 2025-03-03 в 15.04.05.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>С документацией можно ознакомиться по <a href="https://docs.qgis.org/3.40/en/docs/training_manual/complete_analysis/raster_to_vector.html">ссылке</a>.</p>
<p>Пример работы автоматического векторизатора показан ниже.</p>
<iframe width="800" height="400" src="https://www.youtube.com/embed/mQmw3N1dLFo?si=G95HGqiv-xtGZNmg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p>Так как автоматическая векторизация здесь осуществляется фактически только по цвету пикселей вашего растра, то идеальным случаем для векторизации будут большие полигоны с равномерной заливкой и без контура, в других случаях вы можете получить слишком много маленьких полигонов, которые будут требовать дополнительной проработки и объединения.</p>
<p>Также следует отметить, что полученные полигоны не будут иметь гладкие и ровные стороны, а будут своеобразными “лесенками”, в силу того, что пиксели напрямую преобразовываются в объекты.</p>
</div>
</div>
</section>
<section id="модуль-bunting-labs-ai" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="модуль-bunting-labs-ai"><span class="header-section-number">3.2</span> Модуль Bunting labs AI</h3>
<p>Страница модуля: <a href="https://plugins.qgis.org/plugins/buntinglabs-qgis-plugin/" class="uri">https://plugins.qgis.org/plugins/buntinglabs-qgis-plugin/</a></p>
<p>Сайт модуля: <a href="https://buntinglabs.com/solutions/ai-vectorizer-qgis-plugin" class="uri">https://buntinglabs.com/solutions/ai-vectorizer-qgis-plugin</a></p>
<p>Репозиторий с кодом: <a href="https://github.com/BuntingLabs/buntinglabs-qgis-plugin" class="uri">https://github.com/BuntingLabs/buntinglabs-qgis-plugin</a></p>
<p>В январе 2024 года компания Bunting Labs выпустила плагин для QGIS Bunting Labs AI Vectorizer, который помогает оцифровывать растры, продолжая линии, начатые пользователем. Разработчики называют это “автозаполнением”, потому что плагин не делает всю работу сразу, а дорисовывает части линий на основе контекста, оставляя пользователю возможность в любой момент перехватить контроль.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>Плагин <strong>AI Vectorizer</strong> работает так: когда пользователь начинает отрисовывать векторный объект, модель “смотрит” на его действия и продолжает эту линию, независимо от ее значения.</p>
<p>Пользователь начинает оцифровывать линию или полигон по растру, и как только есть первые две вершины, маленький кусочек карты отправляется на сервер. Модель “смотрит” на нарисованный на карте отрезок и выбирает пиксели, по которым должны проходить следующие вершины, после чего плагин дорисовывает 50 следующих точек линии. Этот процесс подходит для любых линий, даже для пунктирных и тех, которые пересекают другие похожие объекты. А если плагин собьется с пути, можно просто отменить последний шаг и не терять при этом много времени.</p>
<p>Перед работой необходимо зарегистрировать аккаунт по <a href="https://buntinglabs.com/account/register">ссылке</a>. После этого вам на указанную в форме электронную почту придет письмо для активации аккаунта.</p>
<p>Далее следует установить модуль <strong>Bunting Labs AI Vectorizer.</strong></p>
<iframe width="800" height="400" src="https://www.youtube.com/embed/PKEuQS4sMJE?si=5KlOz7JT4-WM5aPq" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p>Судя по всему модуль теперь работает бесплатно только в течение 30 дней с момента активации работы с ним.</p>
</div>
</div>
<iframe width="800" height="400" src="images/miscgif.mp4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<iframe width="800" height="400" src="images/miscgif3.mp4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Также в модуль входит сервис привязки с использованием искусственного интеллекта https://buntinglabs.com/solutions/ai-georeferencer.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/qgis-button.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>В качестве бесплатной альтернативы можно воспользоваться модулем <a href="https://github.com/mkondratyev85/raster_tracer">Raster tracer</a>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/screen.gif" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>Краткую инструкцию по работе с модулем можно прочитать по <a href="https://vk.com/wall62864383_1594">ссылке</a> или посмотреть видео.</p>
<iframe width="600" height="400" src="https://www.youtube.com/embed/vHH1dYonmfo?si=l4qfOF3z0PiPMXWh" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<p>Этот модуль работает только для линейных объектов, но при необходимости контура можно впоследствии преобразовать в полигоны.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Снимок экрана 2025-03-12 в 12.28.16.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
</div>
</div>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p><strong>Changelog for version: 3.42</strong> <a href="https://changelog.qgis.org/en/qgis/version/3.42/" class="uri">https://changelog.qgis.org/en/qgis/version/3.42/</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><strong>Плагин для AI-оцифровки растров в QGIS -</strong> <a href="https://cartetika.ru/tpost/4dta8sa621-plagin-dlya-ai-otsifrovki-rastrov-v-qgis" class="uri">https://cartetika.ru/tpost/4dta8sa621-plagin-dlya-ai-otsifrovki-rastrov-v-qgis</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // default icon
          link.classList.add("external");
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>